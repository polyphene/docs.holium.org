"use strict";(self.webpackChunkholium_docs=self.webpackChunkholium_docs||[]).push([[795],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return m}});var a=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),d=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=d(n),m=o,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return n?a.createElement(h,r(r({ref:t},c),{},{components:n})):a.createElement(h,r({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4813:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return c},default:function(){return u}});var a=n(7462),o=n(3366),i=(n(7294),n(3905)),r=["components"],s={sidebar_label:"Design",sidebar_position:1},l="Design",d={unversionedId:"reference/design",id:"reference/design",isDocsHomePage:!1,title:"Design",description:"On this page are defined the inner workings of the lowest storage layer in Holium, based on linked data, that gives",source:"@site/docs/reference/design.md",sourceDirName:"reference",slug:"/reference/design",permalink:"/docs.holium.org/reference/design",editUrl:"https://github.com/polyphene/holium-docs/blob/main/docs/reference/design.md",version:"current",sidebarPosition:1,frontMatter:{sidebar_label:"Design",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Guides",permalink:"/docs.holium.org/guides"},next:{title:"CLI",permalink:"/docs.holium.org/reference/cli"}},c=[{value:"Reference schema",id:"reference-schema",children:[{value:"Data",id:"data",children:[]},{value:"Execution",id:"execution",children:[]},{value:"Pipelines",id:"pipelines",children:[]},{value:"Other kinds",id:"other-kinds",children:[]}]},{value:"Additional considerations",id:"additional-considerations",children:[{value:"Versioning strategy",id:"versioning",children:[]},{value:"Lexical ordering of pipeline vertices",id:"pipeline-dag-lexical-order",children:[]}]},{value:"Contributing",id:"contributing",children:[{value:"Holium Improvement Proposal (HIP)",id:"holium-improvement-proposal-hip",children:[]},{value:"Validation",id:"validation",children:[]},{value:"Resources",id:"resources",children:[]}]}],p={toc:c};function u(e){var t=e.components,n=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"design"},"Design"),(0,i.kt)("p",null,"On this page are defined the inner workings of the lowest storage layer in Holium, based on linked data, that gives\nevery component in the framework a unique identifier."),(0,i.kt)("p",null,"In line with the ",(0,i.kt)("a",{parentName:"p",href:"/docs.holium.org/about-holium/design-principles"},"vision and principles")," of the project, some objectives of the\nprotocol are directly linked to this layer. Among others, providing a way to always share bits of data together with\ntheir history, so that datasets are never cut away from any lineage information, and facilitating collaboration on data\ntransformation pipelines."),(0,i.kt)("p",null,"To define something, it is often as useful to specify what it is not than what it is."),(0,i.kt)("p",null,"On one hand, the purpose of this layer is a ",(0,i.kt)("strong",{parentName:"p"},"description")," one. It basically serves as the lowest ",(0,i.kt)("em",{parentName:"p"},"self-describing,\nautonomous")," storage layer, where archives of any information related to data transformation could lie. Its construction\nfocuses on ",(0,i.kt)("strong",{parentName:"p"},"completeness")," of stored objects, so that one identifier could identify entire unforgeable archives, and ",(0,i.kt)("strong",{parentName:"p"},"\nmodularity")," to foster re-usability of any stored component."),(0,i.kt)("p",null,"On the other hand, querying datasets based on or related to transformation pipelines, or comparing these assets, does\nnot figure in the scope of this architectural layer."),(0,i.kt)("h2",{id:"reference-schema"},"Reference schema"),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"info ")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"This document serves as the actual reference schema for all objects in the Holium framework. Indications\nrelated to testing and contributing can be found at the end of it."))),(0,i.kt)("p",null,"To unlock collaboration in open networks, common loose frames of data representations are not enough and the very\nrepresentations need to be unified. Truly universal identifiers are required. That is why Holium takes advantage\nof ",(0,i.kt)("a",{parentName:"p",href:"https://multiformats.io/"},"multiformats")," and ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/multiformats/cid"},"Content IDentifiers (CID)"),". Using\nthese self-describing content-based identifiers, ready for distributed systems, the aim is to ensure that any object in\nthe framework may be represented in one unique way, which only depends on its content and never on external elements\nlike its location or its creator. Given that, users can then go beyond any problem of data representation and focus one\nwhat they actually want to use these objects for."),(0,i.kt)("p",null,"Throughout this document, some rules are specified with the primary goal of enforcing deterministic representation of\nall objects. Among these, the first ones are related to multiformat configuration. For any CID in the protocol:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Multihashes use the BLAKE3 algorithm (code ",(0,i.kt)("inlineCode",{parentName:"li"},"0x1e"),") with its default 32 byte output length."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"cbor")," (code ",(0,i.kt)("inlineCode",{parentName:"li"},"0x51"),") multicodec is used for serialization.")),(0,i.kt)("p",null,"The model is defined as an ",(0,i.kt)("a",{parentName:"p",href:"https://ipld.io/docs/schemas/"},"IPLD schema"),". For ease of understanding, the focus is first\nput on the three important kinds that enable the representation of transformation history of datasets, but the same\nmodel also supports the description of other objects (dry/data-free pipeline structures, metadata,...) specified\nafterwards."),(0,i.kt)("h3",{id:"data"},"Data"),(0,i.kt)("p",null,"The first kinds to be studied are the ones in charge of data and datasets themselves. As covered in\nthe ",(0,i.kt)("a",{parentName:"p",href:"/docs.holium.org/about-holium/design"},"design introduction"),", scalar values are stored as they are while recursive structures\nare only made of links to other scalar or recursive data structures."),(0,i.kt)("p",null,"Apart from the use of the ",(0,i.kt)("inlineCode",{parentName:"p"},"AnyScalar")," union type to encompass all scalar values, this first excerpt of the schema also\nintroduces the ",(0,i.kt)("a",{parentName:"p",href:"#versioning"},"versioning strategy")," covered in more details in a dedicated section of this document."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ipdsch"},'## =====\n## This schema describes structures used in the Holium Framework.\n##\n## Version : 0\n## =====\n\n## AnyScalar defines a union of the basic non-complex kinds.\n## Reference: https://github.com/ipld/ipld/blob/master/specs/schemas/schema-schema.ipldsch\ntype AnyScalar union {\n    | Bool bool\n    | String string\n    | Bytes bytes\n    | Int int\n    | Float float\n} representation kinded\n\n## ScalarData_v0, the first kind of Holium data object, is a simple Copy of IPLD AnyScalar.\ntype ScalarData_v0 = AnyScalar\n\n## ScalarDataEnvelope_v0 is an enveloped content pointing to ScalarData_v0.\ntype ScalarDataEnvelope_v0 &ScalarData_v0\n\n## ScalarDataEnvelope_Typed_v0 is the typed version of ScalarData envelopes for protocol v0.\ntype ScalarDataEnvelope_Typed_v0 union {\n    | ScalarDataEnvelope_v0 "sde_0"\n} representation envelope {\n    discriminantKey "typedVersion"\n    contentKey "content"\n}\n')),(0,i.kt)("p",null,"As foreseen, the schema acknowledges recursive data structures as lists of links to other data values, scalar or\nrecursive."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ipldsch"},'## RecursiveData_v0, the second kind of Holium data object, is a list of links towards\n## other Holium data blocks.\ntype RecursiveData_v0 [RecursiveDataElement_v0]\n\n## RecursiveDataElement_v0 is a simple Copy of the Link kind.\n## It is mostly a placeholder for the day IPLD specifications allow to create an expressive\n## kinded union of links to both scalar and recursive data types.\ntype RecursiveDataElement_v0 = Link\n\n## RecursiveDataEnvelope_v0 is an enveloped content pointing to RecursiveData_v0.\ntype RecursiveDataEnvelope_v0 &RecursiveData_v0\n\n## RecursiveDataEnvelope_Typed_v0 is the typed version of RecursiveData envelopes for protocol v0.\ntype RecursiveDataEnvelope_Typed_v0 union {\n    | RecursiveDataEnvelope_v0 "rde_0"\n} representation envelope {\n    discriminantKey "typedVersion"\n    contentKey "content"\n}\n')),(0,i.kt)("p",null,"With these two first kinds, any data, either structured or complex, can equally be introduced in the Holium framework\nand included in virtually any dataset. In the process, data re-usability is maximized as any data, scalar or not, will\nconsistently be represented in the exact same way and benefit from the exact content-based universal identifier, while\nrecursive data only hold links and never copies of initial data."),(0,i.kt)("h3",{id:"execution"},"Execution"),(0,i.kt)("p",null,"The second important kind is the one in charge of describing the result of the execution of a transformation. This part\nof the architecture has also been introduced in the ",(0,i.kt)("a",{parentName:"p",href:"/docs.holium.org/about-holium/design"},"design introduction")," and, as a reminder,\ninvolves WebAssembly functions ingesting and digesting datasets. More precisely, a transformation always ingests a\nsingle ",(0,i.kt)("inlineCode",{parentName:"p"},"RecursiveData"),"\nobject as an input parameter and, in case of success, outputs a single ",(0,i.kt)("inlineCode",{parentName:"p"},"RecursiveData")," object which respectively hold\nall the input and output values of the transformation and may be structured and structured with the help of a\ntransformation SDK."),(0,i.kt)("p",null,"First, a module bytecode is represented with a dedicated kind."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ipldsch"},'## ModuleBytecode_v0 is the type of data storing Wasm module bytecode.\n## At some point, the FlexibleByteLayout could be a better implementation choice.\n## Reference: https://github.com/ipld/ipld/blob/master/specs/advanced-data-layouts/fbl/spec.md\ntype ModuleBytecode_v0 bytes\n\n## ModuleBytecodeEnvelope_v0 is an enveloped content pointing to ModuleBytecode_v0.\ntype ModuleBytecodeEnvelope_v0 &ModuleBytecode_v0\n\n## ModuleBytecodeEnvelope_Typed_v0 is the typed version of ModuleBytecode envelopes for protocol v0.\ntype ModuleBytecodeEnvelope_Typed_v0 union {\n    | ModuleBytecodeEnvelope_v0 "mbe_0"\n} representation envelope {\n    discriminantKey "typedVersion"\n    contentKey "content"\n}\n')),(0,i.kt)("p",null,"Then comes the kind describing the result of an execution itself. That is, for a given module and handle, pointing to a\nspecific pure function in the module, and given an input value, one may use this type to express the result of the\nexecution, attaching an exit status and, in case of success, an output data."),(0,i.kt)("p",null,"This very kind is a fundamental element of the expression of the history of transformations of any dataset."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ipldsch"},'## Execution_v0 is a kind that allows expressing the result of the execution of\n## a specific transformation on a specific dataset. The transformation is identified\n## through its bytecode and handle, input and (optional) output of the execution\n## are of the RecursiveData kind, while the exit status is a 0 or 1 exit code,\n## coding for success or failure respectively.\ntype Execution_v0 struct {\n  bytecode      &ModuleBytecodeEnvelope_Typed_v0\n  handle        String\n  input         &RecursiveDataEnvelope_Typed_v0\n  exitStatus    bool\n  output        &RecursiveDataEnvelope_Typed_v0\n} representation tuple\n\n## Execution_Typed_v0 is the typed version of Execution for protocol v0.\ntype Execution_Typed_v0 union {\n    | Execution_v0 "ex_0"\n} representation envelope {\n    discriminantKey "typedVersion"\n    contentKey "content"\n}\n')),(0,i.kt)("h3",{id:"pipelines"},"Pipelines"),(0,i.kt)("p",null,"To connect transformed datasets to all source datasets that they originate from, a last kind is necessary, which\nbasically connects each execution as an intermediary stage of a complete transformation process. This last kind is the\none describing shapes of pipelines."),(0,i.kt)("p",null,"As introduced in the ",(0,i.kt)("a",{parentName:"p",href:"/docs.holium.org/about-holium/design"},"design overview"),", chaining transformations basically comes down to the\nconnection of indexes. As, in Holium, the input parameter of a transformation is a single list structure, holding nested\nlists and/or scalars, each input element can be precisely identified with a set of indices. This is the purpose of ",(0,i.kt)("em",{parentName:"p"},"\nselectors"),": to target precise elements inside input and output parameters. To connect a transformation to others and\nform a pipeline, one needs to connect each element of its input parameter to elements of output parameters coming from its\npreceding transformations, through ",(0,i.kt)("em",{parentName:"p"},"connections"),", introduced here and described in more detail\nin ",(0,i.kt)("a",{parentName:"p",href:"#selectors-and-connections"},"subsequent section"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ipldsch"},'## Selector_v0, used in protocol v0, is a Copy of SelectorEnvelope.\ntype Selector_v0 = SelectorEnvelope\n\n## The Connection_v0 type is used to connect a tail selector, basically\n## selecting pieces of a transformation output, to a head selector\n## of same topology, selecting parts of a transformation input.\ntype Connection_v0 struct {\n  tailSelector  &Selector_v0\n  headSelector  &Selector_v0\n} representation tuple\n\n## Connection_Typed_v0 is the typed version of Connection for protocol v0.\ntype Connection_Typed_v0 union {\n    | Connection_v0 "cx_0"\n} representation envelope {\n    discriminantKey "typedVersion"\n    contentKey "content"\n}\n')),(0,i.kt)("p",null,"To be accurate, more than chains, pipelines are really Directed Acyclic Graphs (DAG) of transformations."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ipldsch"},'## Pipeline vertices are of type PipelineVertex_v0.\n## See the Pipeline_v0 structure for more details.\ntype PipelineVertex_v0 {String:Link} representation map\n\n## Pipeline edges are of type PipelineEdge_v0.\n## See the Pipeline_v0 structure for more details.\ntype PipelineEdge_v0 struct {\n  tailIndex     int\n  headIndex     int\n  connection    &Connection_Typed_v0\n} representation tuple\n\n## The Pipeline_v0 structure describes topologies of Directed Acyclic Graphs (DAG)\n## defined primarily by their edges.\n## Firstly, in these DAGs, vertices represent transformations and can be conceived\n## as containers which content may vary according to the context. They may be empty\n## if the only purpose of the pipeline is topological; they may hold\n## transformations only, to represent transformation pipelines at rest; they may also,\n## of course, hold data and executions to trace the transformation history of datasets.\n## In the end, any type of information may be attached to these vertices.\n## Secondly, edges connect these vertices together through pairs of IPLD selectors.\n## They connect pieces of output parameters from preceding transformations (tail of\n## the edge) to parts of input parameters of following transformations (head of \n## the edge).\n## Assembled together, they should form a DAG, eventually made of transformations\n## and datasets: the pipeline.\ntype Pipeline_v0 struct {\n  vertices  [PipelineVertex_v0]\n  edges     [PipelineEdge_v0]\n} representation tuple\n\n## Pipeline_Typed_v0 is the typed version of Pipeline for protocol v0.\ntype Pipeline_Typed_v0 union {\n    | Pipeline_v0 "pl_0"\n} representation envelope {\n    discriminantKey "typedVersion"\n    contentKey "content"\n}\n')),(0,i.kt)("p",null,"In summary, the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pipeline")," structure defines ",(0,i.kt)("strong",{parentName:"p"},"topologies of DAGs")," which vertices are connected with pairs of selectors\nidentifying parts of Holium data structures."),(0,i.kt)("p",null,"Nodes, for their part, may link to various kinds of information, from dry transformations to datasets and executions. They\nare made of maps from String keys to IPLD Links, in which keys should use the same lexicon as the short descriptors\ndefined in the ",(0,i.kt)("a",{parentName:"p",href:"#versioning"},"versioning")," specification (",(0,i.kt)("inlineCode",{parentName:"p"},"rde")," for Recursive Data envelopes, ",(0,i.kt)("inlineCode",{parentName:"p"},"ex")," for Executions, ",(0,i.kt)("inlineCode",{parentName:"p"},"dt"),"\nfor Dry Transformations,\u2026), arranged in alphabetical order."),(0,i.kt)("p",null,"To ensure determinism of their representations, additional rules based on a simple lexical ordering are explained in\na ",(0,i.kt)("a",{parentName:"p",href:"#pipeline-dag-lexical-order"},"subsequent section"),"."),(0,i.kt)("h3",{id:"other-kinds"},"Other kinds"),(0,i.kt)("h4",{id:"dry-transformation"},"Dry transformation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ipldsch"},'## DryTransformation_v0 is a kind specifying a module bytecode and a handle, that\n## may be introduced in a pipeline and that does not encompass its execution,\n## thus does not link to any specific data value.\ntype DryTransformation_v0 struct {\n  bytecode      &ModuleBytecodeEnvelope_Typed_v0\n  handle        String\n} representation tuple\n\n## DryTransformation_Typed_v0 is the typed version of DryTransformation for protocol v0.\ntype DryTransformation_Typed_v0 union {\n    | DryTransformation_v0 "dt_0"\n} representation envelope {\n    discriminantKey "typedVersion"\n    contentKey "content"\n}\n')),(0,i.kt)("h4",{id:"selectors-and-connections"},"Selectors and connections"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ipldsch"},'## Selectors used in Holium are a subset of IPLD Selectors.\n## Reference: https://ipld.io/specs/selectors/\n\n## SelectorEnvelope is the recommended top-level value for serialized messages\n## that don\'t have established existing context with marks the start of a selector:\n## it\'s a single-member union used to kick us towards "nominative typing".\n##\n## See https://github.com/ipld/specs/tree/master/schemas/migration.md\n## for a background on the theory behind this gentle-nominative concept.\ntype SelectorEnvelope union {\n    | Selector "selector"\n} representation keyed\n\ntype Selector union {\n    | Matcher "."\n    | ExploreIndex "i"\n    | ExploreRange "r"\n    | ExploreUnion "|"\n} representation keyed\n\n## Matcher marks a node to be included in the "result" set.\n## (All nodes traversed by a selector are in the "covered" set (which is a.k.a.\n## "the merkle proof"); the "result" set is a subset of the "covered" set.)\n##\n## In libraries using selectors, the "result" set is typically provided to\n## some user-specified callback.\n##\n## A selector tree with only "explore*"-type selectors and no Matcher selectors\n## is valid; it will just generate a "covered" set of nodes and no "result" set.\ntype Matcher struct {\n    label optional String # labels can be used to match multiple different structures in one selection.\n}\n\n## ExploreIndex traverses a specific index in a list, and applies a next\n## selector to the reached node.\ntype ExploreIndex struct {\n    index Int (rename "i")\n    next Selector (rename ">")\n}\n\n## ExploreRange traverses a list, and for each element in the range specified,\n## will apply a next selector to those reached nodes.\ntype ExploreRange struct {\n    start Int (rename "^")\n    end Int (rename "$")\n    next Selector (rename ">")\n}\n\n## ExploreUnion allows selection to continue with two or more distinct selectors\n## while exploring the same tree of data.\n##\n## ExploreUnion can be used to apply a Matcher on one node (causing it to\n## be considered part of a (possibly labelled) result set), while simultaneously\n## continuing to explore deeper parts of the tree with another selector,\n## for example.\ntype ExploreUnion [Selector]\n')),(0,i.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Additional specifications should be expected in order to enforce determinism of these representations.\nWork in progress. \ud83d\udea7"))),(0,i.kt)("h2",{id:"additional-considerations"},"Additional considerations"),(0,i.kt)("h3",{id:"versioning"},"Versioning strategy"),(0,i.kt)("p",null,"All complex schemas in the framework are versioned at the protocol level."),(0,i.kt)("p",null,"The simple strategy is based on discriminant keys coding for both the structure and the protocol version.\nA schema for ",(0,i.kt)("em",{parentName:"p"},"execution")," (coded ",(0,i.kt)("inlineCode",{parentName:"p"},"ex"),") for protocol version 0 will for instance have the key ",(0,i.kt)("inlineCode",{parentName:"p"},"ex_0"),"."),(0,i.kt)("p",null,"Here is the index of short kind descriptors :"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Kind"),(0,i.kt)("th",{parentName:"tr",align:null},"Short Descriptor"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Scalar Data envelope"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sde"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Recursive Data envelope"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"rde"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Module Bytecode envelope"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"mbe"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Execution"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"ex"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Dry Transformation"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"dt"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Connection"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"cx"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Pipeline"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"pl"))))),(0,i.kt)("p",null,"When defining schemas for a new version of the protocol, each complex schema has a ",(0,i.kt)("em",{parentName:"p"},"versionized")," version. If a\nkind does not change, then Copy is simply used:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ipldsch"},"type Type_vY = Type_vX\n")),(0,i.kt)("p",null,"Then, a simple enumeration implements the keyed versioning strategy. Here is an example with the schema of ",(0,i.kt)("em",{parentName:"p"},"executions"),"\nat protocol version 1."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ipldsch"},'type Execution_Typed_v1 union {\n    | Execution_v1 "ex_1"\n    | Execution_v0 "ex_0"\n} representation keyed\n')),(0,i.kt)("p",null,"For more information on versioning strategies, have a look at\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://specs.ipld.io/schemas/migration.html"},"official documentation"),"."),(0,i.kt)("h3",{id:"pipeline-dag-lexical-order"},"Lexical ordering of pipeline vertices"),(0,i.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Work in progress. \ud83d\udea7"))),(0,i.kt)("h2",{id:"contributing"},"Contributing"),(0,i.kt)("h3",{id:"holium-improvement-proposal-hip"},"Holium Improvement Proposal (HIP)"),(0,i.kt)("p",null,"These open specifications are constantly discussed and improved by the community,\nfollowing a process made of proposals known as HIPs."),(0,i.kt)("p",null,"If you would like to contribute, check the ",(0,i.kt)("a",{parentName:"p",href:"/docs.holium.org/contributing#hip"},"dedicated guidelines"),"."),(0,i.kt)("h3",{id:"validation"},"Validation"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"ipld-schema")," module should be used to validate the format of the schema, working directly on current\nfile: ",(0,i.kt)("inlineCode",{parentName:"p"},"npx ipld-schema validate ./holium-schema.md"),"."),(0,i.kt)("h3",{id:"resources"},"Resources"),(0,i.kt)("p",null,"Find more information on IPLD ",(0,i.kt)("a",{parentName:"p",href:"https://ipld.io/"},"website"),", ",(0,i.kt)("a",{parentName:"p",href:"https://docs.ipld.io/"},"documentation"),"\nand ",(0,i.kt)("a",{parentName:"p",href:"https://specs.ipld.io/"},"specifications"),"."))}u.isMDXComponent=!0}}]);